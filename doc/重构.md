
## 问题：
1. 不要有太多选择： dispatch就是参考notifier，不需要action
2. 在组件状态下创建：有没有init过程？
3. Store.Create<>(instance,'key',dispose)  Store.remove('key')
4. listen, get...前者监听，后者获取....实际上Store.store<T>('key')就能得到，无需context



## 下一项：
我们是直接使用first等变量，显示counter
1. 接下来任务：通过of获取、通过Store获取
2. 可使用mixin，避免各处饮用iconnect
3. stream创建一个实例，处理异常
4. 保存和载入
5. 自动保存和自动载入
6. 进度处理和stream、异常、重试等

## 问题
出现异常：
JSNoSuchMethodError (TypeError: Cannot read properties of undefined (reading 'loader'))
解决：这是调试窗口里，勾选了All Exception，去掉即可
不过，删除web目录，重新创建，即使勾选了也正常
所以这本质上是新版本的flutter和旧的web文件夹的冲突.....

## 问题：
解决：将aspect改成字符串key即可
但继续调试后，可以显示ui
按钮均不工作
注意，这里的dependencies是自动的记录的，每个listen的组件，均要检查一次。set中始终只有一个元素
我们并未将store放在inheritedModel里....



## 如何使用？

方法1: goroute的方式，但共用同一个provider

使用一个inheritedWidget，保存一个goRouter对象
class GoRouter extends ChangeNotifier
    with NavigatorObserver
    implements RouterConfig<RouteMatchList> 
这说明changeNotifier是可正常的直接使用的。
所以同样：继承自ChangeNotifier, 一个mixin监测，注意这里的技巧，监测只是定义了几个时机，函数为空，这里覆盖了mixin的所有函数，用notifierListen

实现routeConfig


方法2:
Store.Provider() 注意这里就创建一个store
Store.add<Counter>(Counter(),key,dispose); //创建
Store.remove<Counter>(key) //删除
Store.of<Counter>([key],listen:true) 这里获取Counter对象
Store.dispatch<Counter>(fn,[key])
要注意，不要重新创建Store，所以需要在顶层，且任何时候不要在最顶层setState，同时尽量的使用const

与现有的方式相比，首先均是强类型的
map<type,data>
data包括：1.default instance; dispose;  map<string,dynamic >
或者map<type,实例>,map<type,dispose>,map<string,实例>
string的实例奇dispose从type获取。

当然另一种方法是sharedValue的方法，

## 使用type为key

Map<Type, dynamic>
这样我们无需将实例当作key？实例到底有多大，需要单元测试尝试一下
如果实例仅仅是引用，则无需修改

## 需要使用字符串键，用于保存和读取

## 将sqlite部分的存取方法，作为一个接口处理

## 修改setState
Future<void> dispatch() async {
    if (!mounted) return;

    // if there's a current frame,
    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.idle) {
      // wait for the end of that frame.
      await SchedulerBinding.instance.endOfFrame;
      if (!mounted) return;
    }

    setState(() {});
  }