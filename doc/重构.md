
## 使用lint
dev依赖下加入flutter_lint即可，修复所有的警告信息。


## 思路：简化使用，多数事情只需要一种方式，不要有多种可选的方式
1. 删除了mixin方式，道理很简单：
    model完全只考虑类本身，不需要考虑dispatch之类
    虽然使用model的时候需要import iconnect，但model和ui之间不能混杂
2. 去掉register的时候，dispose参数，如果model定义了dipose函数，则unregister的时候执行
3. dispatch去掉了action的概念，只是发出rebuild指令

4. 是否需要去掉全局变量first，second这类？比如Store<T>(key)获取
5. 提供一个入口，在启动的时候创建所有需要预先载入的全局对象？

## 问题：
1. 完成：不要有太多选择： dispatch就是参考notifier，不需要action
1. 完成：model可以使用mixin，可以用函数来使用dispatch...可以创建的时候register...
   正常流程是Store.Create(model,key,dispose),不要在构造函数中创建，这意味着要增加key字段
   同时dispose是否可以由model提供，检查该类型是否有dispose函数

   

1. 在组件状态下创建：有没有init过程？ 没有，因为dispatch是唯一的rebuild接口，创建时并没有

3. Store.Create<>(instance,'key',dispose)  Store.remove('key')
4. listen, get...前者监听，后者获取....实际上Store.store<T>('key')就能得到，无需context

## 下一项：
我们是直接使用first等变量，显示counter
1. 接下来任务：通过of获取、通过Store获取
2. 可使用mixin，避免各处饮用iconnect
3. stream创建一个实例，处理异常
4. 保存和载入
5. 自动保存和自动载入
6. 进度处理和stream、异常、重试等

## 问题
出现异常：
JSNoSuchMethodError (TypeError: Cannot read properties of undefined (reading 'loader'))
解决：这是调试窗口里，勾选了All Exception，去掉即可
不过，删除web目录，重新创建，即使勾选了也正常
所以这本质上是新版本的flutter和旧的web文件夹的冲突.....

## 问题：
解决：将aspect改成字符串key即可
但继续调试后，可以显示ui
按钮均不工作
注意，这里的dependencies是自动的记录的，每个listen的组件，均要检查一次。set中始终只有一个元素
我们并未将store放在inheritedModel里....



## 如何使用？

方法1: goroute的方式，但共用同一个provider

使用一个inheritedWidget，保存一个goRouter对象
class GoRouter extends ChangeNotifier
    with NavigatorObserver
    implements RouterConfig<RouteMatchList> 
这说明changeNotifier是可正常的直接使用的。
所以同样：继承自ChangeNotifier, 一个mixin监测，注意这里的技巧，监测只是定义了几个时机，函数为空，这里覆盖了mixin的所有函数，用notifierListen

实现routeConfig


方法2:
Store.Provider() 注意这里就创建一个store
Store.add<Counter>(Counter(),key,dispose); //创建
Store.remove<Counter>(key) //删除
Store.of<Counter>([key],listen:true) 这里获取Counter对象
Store.dispatch<Counter>(fn,[key])
要注意，不要重新创建Store，所以需要在顶层，且任何时候不要在最顶层setState，同时尽量的使用const

与现有的方式相比，首先均是强类型的
map<type,data>
data包括：1.default instance; dispose;  map<string,dynamic >
或者map<type,实例>,map<type,dispose>,map<string,实例>
string的实例奇dispose从type获取。

当然另一种方法是sharedValue的方法，

## 使用type为key

Map<Type, dynamic>
这样我们无需将实例当作key？实例到底有多大，需要单元测试尝试一下
如果实例仅仅是引用，则无需修改

## 需要使用字符串键，用于保存和读取

## 将sqlite部分的存取方法，作为一个接口处理

## 修改setState
Future<void> dispatch() async {
    if (!mounted) return;

    // if there's a current frame,
    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.idle) {
      // wait for the end of that frame.
      await SchedulerBinding.instance.endOfFrame;
      if (!mounted) return;
    }

    setState(() {});
  }